package diff

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// Apply parses the custom side-by-side diff output and applies the changes to the target directory.
// It assumes the patch was generated by `Diff` and is in standard text format (not TermMode, or stripped).
func Apply(patchContent string, targetDir string) error {
	lines := strings.Split(patchContent, "\n")
	var blockLines []string
	var currentFile string

	for _, line := range lines {
		if strings.HasPrefix(line, "Diff ") {
			// Process previous block
			if currentFile != "" {
				if err := processBlock(currentFile, blockLines); err != nil {
					return err
				}
			}
			blockLines = nil

			// Parse header
			var p1, p2 string
			// Try to parse quoted paths
			n, err := fmt.Sscanf(line, "Diff %q %q", &p1, &p2)
			if err != nil || n != 2 {
				// Fallback to space split if parsing fails (though Walker produces quotes now)
				parts := strings.Fields(line)
				if len(parts) >= 3 {
					// parts[0] is Diff
					// parts[1] is path1
					// parts[2] is path2
					p1 = parts[1]
					p2 = parts[2]
				} else {
					currentFile = ""
					continue
				}
			}

			// Determine target file path
			// We use p1 relative to targetDir.
			// If p1 contains directory separators, Join handles them.
			currentFile = filepath.Join(targetDir, p1)

			// Basic path traversal check
			// Ensure currentFile is within targetDir
			rel, err := filepath.Rel(targetDir, currentFile)
			if err != nil {
				// Failed to check relation, maybe different volumes on Windows?
				// Reject to be safe.
				return fmt.Errorf("invalid path %s relative to %s: %v", p1, targetDir, err)
			}
			if strings.HasPrefix(rel, ".."+string(filepath.Separator)) || rel == ".." {
				return fmt.Errorf("path %s escapes target directory %s", p1, targetDir)
			}
			continue
		}

		if currentFile != "" {
			blockLines = append(blockLines, line)
		}
	}
	// Process last block
	if currentFile != "" {
		if err := processBlock(currentFile, blockLines); err != nil {
			return err
		}
	}
	return nil
}

func processBlock(path string, lines []string) error {
	if len(lines) == 0 {
		// Empty block implies empty file content (or identical content but Diff outputted header only?)
		// Walker outputs header + formatted diff.
		// If formatted diff is empty string, then lines is empty.
		// This happens if files are identical and FormatDiff returns empty?
		// But FormatDiff returns side-by-side view.
		// So lines should not be empty unless files are truly empty.
		// Create empty file.
		if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
			return err
		}
		return os.WriteFile(path, []byte{}, 0644)
	}

	// 1. Determine separator index (maxLeft)
	separators := map[string]bool{
		" == ": true, " 1d ": true, " 2d ": true, " 3d ": true, " 4d ": true, " 5d ": true, " 6d ": true, " 7d ": true, " 8d ": true, " 9d ": true, " +d ": true, " d  ": true, " w  ": true, " q  ": true, " $  ": true,
		// Trimmed versions (when right side is empty)
		" ==": true, " 1d": true, " 2d": true, " 3d": true, " 4d": true, " 5d": true, " 6d": true, " 7d": true, " 8d": true, " 9d": true, " +d": true, " d": true, " w": true, " q": true, " $": true,
	}

	// Find consistent separator index
	// Candidates from first line
	firstLine := lines[0]
	var candidates []int
	// Check for separators of length 4, 3, or 2
	for i := 0; i <= len(firstLine)-2; i++ {
		matched := false
		if i+4 <= len(firstLine) && separators[firstLine[i:i+4]] {
			matched = true
		} else if i+3 <= len(firstLine) && separators[firstLine[i:i+3]] {
			matched = true
		} else if i+2 <= len(firstLine) && separators[firstLine[i:i+2]] {
			matched = true
		}
		if matched {
			candidates = append(candidates, i)
		}
	}

	validIdx := -1
	for _, idx := range candidates {
		isValid := true
		for _, line := range lines {
			if len(line) == 0 {
				continue
			}
			// Check if line matches any separator at idx
			matched := false
			if len(line) >= idx+4 && separators[line[idx:idx+4]] {
				matched = true
			} else if len(line) >= idx+3 && separators[line[idx:idx+3]] {
				matched = true
			} else if len(line) >= idx+2 && separators[line[idx:idx+2]] {
				matched = true
			}
			if !matched {
				isValid = false
				break
			}
		}
		if isValid {
			validIdx = idx
			break
		}
	}

	if validIdx == -1 {
		return fmt.Errorf("could not parse diff block for %s: separator not found or inconsistent", path)
	}

	// 2. Extract right side
	var content []string
	for _, line := range lines {
		if len(line) == 0 {
			// Skip empty lines (layout artifact or trailing newline)
			continue
		}

		sepLen := 0
		if len(line) >= validIdx+4 && separators[line[validIdx:validIdx+4]] {
			sepLen = 4
		} else if len(line) >= validIdx+3 && separators[line[validIdx:validIdx+3]] {
			sepLen = 3
		} else if len(line) >= validIdx+2 && separators[line[validIdx:validIdx+2]] {
			sepLen = 2
		}

		// Should be safe given validation
		if sepLen == 0 {
			continue
		}

		sub := line[validIdx : validIdx+sepLen]
		sym := strings.TrimSpace(sub)

		var right string
		if len(line) >= validIdx+sepLen {
			right = line[validIdx+sepLen:]
		} else {
			right = ""
		}

		// Logic:
		// If sym != "==" (meaning diff) AND right is empty -> Skip (Deletion)
		// Else -> Keep (match or addition/modification)

		if sym != "==" && right == "" {
			continue
		}

		content = append(content, right)
	}

	// 3. Write to file
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	data := strings.Join(content, "\n")
	return os.WriteFile(path, []byte(data), 0644)
}
