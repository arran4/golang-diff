package diff

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// Apply parses the custom side-by-side diff output and applies the changes to the target directory.
// It assumes the patch was generated by `Diff` and is in standard text format (not TermMode, or stripped).
func Apply(patchContent string, targetDir string) error {
	lines := strings.Split(patchContent, "\n")
	var blockLines []string
	var currentFile string

	for _, line := range lines {
		if strings.HasPrefix(line, "Diff ") {
			// Process previous block
			if currentFile != "" {
				if err := processBlock(currentFile, blockLines); err != nil {
					return err
				}
			}
			blockLines = nil

			// Parse header
			var p1, p2 string
			// Try to parse quoted paths
			n, err := fmt.Sscanf(line, "Diff %q %q", &p1, &p2)
			if err != nil || n != 2 {
				// Fallback to space split if parsing fails (though Walker produces quotes now)
				parts := strings.Fields(line)
				if len(parts) >= 3 {
					// parts[0] is Diff
					// parts[1] is path1
					// parts[2] is path2
					p1 = parts[1]
					p2 = parts[2]
				} else {
					currentFile = ""
					continue
				}
			}

			// Determine target file path
			// We use p1 relative to targetDir.
			// If p1 contains directory separators, Join handles them.
			currentFile = filepath.Join(targetDir, p1)

			// Basic path traversal check
			// Ensure currentFile is within targetDir
			rel, err := filepath.Rel(targetDir, currentFile)
			if err != nil {
				// Failed to check relation, maybe different volumes on Windows?
				// Reject to be safe.
				return fmt.Errorf("invalid path %s relative to %s: %v", p1, targetDir, err)
			}
			if strings.HasPrefix(rel, ".."+string(filepath.Separator)) || rel == ".." {
				return fmt.Errorf("path %s escapes target directory %s", p1, targetDir)
			}
			continue
		}

		if currentFile != "" {
			blockLines = append(blockLines, line)
		}
	}
	// Process last block
	if currentFile != "" {
		if err := processBlock(currentFile, blockLines); err != nil {
			return err
		}
	}
	return nil
}

func processBlock(path string, lines []string) error {
	if len(lines) == 0 {
		// Empty block implies empty file content (or identical content but Diff outputted header only?)
		// Walker outputs header + formatted diff.
		// If formatted diff is empty string, then lines is empty.
		// This happens if files are identical and FormatDiff returns empty?
		// But FormatDiff returns side-by-side view.
		// So lines should not be empty unless files are truly empty.
		// Create empty file.
		if err := os.MkdirAll(filepath.Dir(path), 0755); err != nil {
			return err
		}
		return os.WriteFile(path, []byte{}, 0644)
	}

	// 1. Determine separator index (maxLeft)
	separators := map[string]bool{
		" == ": true, " 1d ": true, " 2d ": true, " d  ": true, " w  ": true, " q  ": true, " $  ": true,
	}

	// Find consistent separator index
	// Candidates from first line
	firstLine := lines[0]
	var candidates []int
	for i := 0; i <= len(firstLine)-4; i++ {
		sub := firstLine[i : i+4]
		if separators[sub] {
			candidates = append(candidates, i)
		}
	}

	validIdx := -1
	for _, idx := range candidates {
		isValid := true
		for _, line := range lines {
			if len(line) == 0 {
				continue
			}
			if len(line) < idx+4 {
				isValid = false
				break
			}
			sub := line[idx : idx+4]
			if !separators[sub] {
				isValid = false
				break
			}
		}
		if isValid {
			validIdx = idx
			break
		}
	}

	if validIdx == -1 {
		return fmt.Errorf("could not parse diff block for %s: separator not found or inconsistent", path)
	}

	// 2. Extract right side
	var content []string
	for _, line := range lines {
		if len(line) == 0 {
			// Skip empty lines (layout artifact or trailing newline)
			continue
		}

		sub := line[validIdx : validIdx+4]
		sym := strings.TrimSpace(sub)

		var right string
		if len(line) >= validIdx+4 {
			right = line[validIdx+4:]
		} else {
			right = ""
		}

		// Logic:
		// If sym != "==" (meaning diff) AND right is empty -> Skip (Deletion)
		// Else -> Keep (match or addition/modification)

		if sym != "==" && right == "" {
			continue
		}

		content = append(content, right)
	}

	// 3. Write to file
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	data := strings.Join(content, "\n")
	return os.WriteFile(path, []byte(data), 0644)
}
